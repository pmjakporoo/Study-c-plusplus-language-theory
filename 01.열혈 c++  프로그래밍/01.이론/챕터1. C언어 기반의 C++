- c++의 확장자는 .cpp이다. 

- #include <iostream> : c++에서는 입출력에 관련된 일을 하기 위해서 해당 헤더파일 선언을 추가해야 한다.
- c++에서는 프로그래머가 정의하는 헤더파일의 선언이 아닌, 표준 헤더파일의 선언에서는 확장자를 생략하기로 약속되어있다.
- std::cout<< '출력대상' : '출력대상'의 위치에는 무엇이든 올 수 있다. 정수, 실수, 문자열, 변수, 문자 등등. 
  - C언어와 달리 서식문자를 이용해 출력 포맷을 지정하지 않아도 데이터의 성격에 따라 적절한 출력이 이뤄진다. 
- << 연산자를 이용한 출력 대상의 연이은 표현이 가능하다.
- <<std::endl : <<연산자를 이용한 std::endl의 출력은 개행으로 이어진다. 
- 키보드로부터 데이터 입력에도 헤더파일 선언문 #include <iostream>이 필요하다.
- 키보드로부터 데이터 입력에는 std::cin과 >> 연산자가 필요하다.
- 변수의 선언은 어디서든 가능하다.
- 키보드로부터 데이터 입력 형식 : std::cin >> '변수';
- 다음의 구조로 연속적인 데이터의 입력을 요구할 수 있다. std::cin>>'변수1'>>'변수2';
- 배열 기반의 문자열 입출력 예시) char name[100]; std::cin>>name;
- std::cout << "내 이름은 " << name << "입니다. \n"; 에서 '\n'과 같은 특수문자는 C언어에서와 같은 의미를 지닌다.
  다만, std::endl로 개행의 역할을 대신할 뿐이다.

- c언어에서는 동일한 이름의 함수가 정의되는 것을 허용하지 않는다. (c언어에서는 함수의 이름만 이용해서 호출 대상을 찾는다.)
- c++언어에서는 함수호출 시 전달되는 인자를 통해서 호출하고자 하는 함수의 구분이 가능하기 때문에
  매개변수의 선언형태가 다르다면, 동일한 이름의 함수 정의를 허용할 수 있다. 이러한 형태의 함수정의를 가리켜
  '함수 오버로딩'이라 한다. (c++언어에서는 함수의 이름과 매개변수의 선언을 이용해서 호출 대상을 찾는다.)
- 함수의 오버로딩이 가능 하려면 매개변수의 선언이 달라야 한다. (즉, 매개변수의 자료형 또는 개수가 달라야 매개변수가 서로 다른 것으로 본다.)
  void MyFunc(int n) {...}과 int MyFunc(int n) {...}는 함수의 반환형이 다른 거지, 함수 명과 매개변수는 동일하기 때문에 이러한 함수들은 오버로딩이 될 수 없다.

-매개변수의 디폴트 값을 줄 수 있는데, 이는 함수 호출 시 인자를 전달하지 않으면 설정한 디폴트 값이 전달된 것으로 간주한다는 뜻이다. 
  매개변수에 디폴트 값이 설정되어 있으면, 선언된 매개변수의 수보다 적은 수의 인자전달이 가능하다.
  그리고 전달되는 인자는 왼쪽에서부터 채워져 나가고, 부족분은 디폴트 값으로 채워진다.
- 함수의 원형을 별도로 선언하는 경우, 매개변수의 디폴트 값은 함수의 원형 선언에만 위치시켜야 한다. 
- 일부분만 디폴트 값을 지정할 때, 오른쪽 매개변수의 디폴트 값을 비우는 형태로는 디폴트 값을 지정할 수 없다.
  즉, 오른쪽 매개변수의 디폴트 값부터 채우는 형태로 정의해야 한다. 
  ex) int YourFunc(int num1, int num2, int num3 = 30) {...}
      int YourFunc(int num1, int num2=20, int num3 = 30) {...}
      int YourFunc(int num1=10, int num2=20, int num3 = 30) {...}

- inline함수란 프로그램 코드라인 안으로 들어가 버린 함수를 의미한다.
  - C언어에서 매크로 함수의 장점: 일반적인 함수에 비해서 실행속도의 이점이 있다. 
  - C언어에서 매크로 함수의 단점: 정의하기가 어렵다.(일반 함수처럼 정의가 안됨) 복잡한 함수를 매크로의 형태로 정의하는데 한계가 있다. 

  매크로 함수의 예)
    #include <iostream>
    #define SQUARE(x) ((x)*(x))

    int main(void) {
      std::cout << SQUARE(5) << std::endl;
      return 0;
    }

  위의 코드는 전처리 과정을 거치면 다음과 같이 변경된다. 
  여기서 중요한 점은 함수의 몸체부분이 함수의 호출문은 대체했다는 점이다.

   #include <iostream>
    #define SQUARE(x) ((x)*(x))

    int main(void) {
      std::cout << ((x)*(x)) << std::endl;
      return 0;
    }

- c++에서 c언어의 매크로 함수의 장점은 유지하되, 단점은 제거한 것이 inline함수이다.
  - 참고로, 매크로를 이용한 함수의 인라인화는 전처리기에 의해서 처리되지만, 키워드 inline을 이용한 함수의 인라인화는 컴파일러에 의해서 처리가 된다. 
    따라서 컴파일러는 함수의 인라인화가 오히려 성능에 해가 된다고 판단할 경우, 이 키워드를 무시해보리기도한다. 
    또한 컴파일러는 필요한 경우 일부 함수를 임의로 인라인처리하기도 한다. 
  - 매크로 함수는 자료형에 의존적이지 않는다. 그러나, 인라인 함수는 자료형에 의존적인 문제를 가지고 있다. 
    - 그러나 c++의 템플릿을 이용하면 매크로 함수와 마찬가지로 자료형에 의존적이지 않은 함수가 된다.

    탬플릿 사용 예시 코드 )
    #include <iostream>
    template <typename T>
    inline T SQUARE(T x) {
      return x*x;
    }

    int main(void) {
      std::cout << SQUARE(5.5) << std::endl;
      std::cout << SQUARE(12) << std::endl;
      return 0;
    }

- 이름공간: 이름을 붙여놓은 공간. 즉, 말그대로 특정 영역에 이름을 붙여주기 위한 문법적 요소이다. 
  - 다른 공간에 존재하는 각각의 A는 구분이 된다. 왜냐하면 공간이 다르기 때문이다. 
  - ::연산자를 범위 지정 연산자라고 하며, 이름공간을 지정할 때 사용하는 연산자이다. 
