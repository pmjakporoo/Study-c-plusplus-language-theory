- c++의 확장자는 .cpp이다. 
- #include <iostream> : c++에서는 입출력에 관련된 일을 하기 위해서 해당 헤더파일 선언을 추가해야 한다.
- c++에서는 프로그래머가 정의하는 헤더파일의 선언이 아닌, 표준 헤더파일의 선언에서는 확장자를 생략하기로 약속되어있다.
- std::cout<< '출력대상' : '출력대상'의 위치에는 무엇이든 올 수 있다. 정수, 실수, 문자열, 변수, 문자 등등. 
  - 언어와 달리 서식문자를 잉요해 출력 포맷을 지정하지 않아도 데이터의 성격에 따라 적절한 출력이 이뤄진다. 
- << 연산자를 이용한 출력 대상의 연이은 표현이 가능하다.
- <<std::endl : <<연산자를 이용한 std::endl의 출력은 개행으로 이어진다. 
- 키보드로부터 데이터 입력에도 헤더파일 선언문 #include <iostream>이 필요하다.
- 키보드로부터 데이터 입력에는 std::cin과 >> 연산자가 필요하다.
- 변수의 선언은 어디서든 가능하다.
- 키보드로부터 데이터 입력 형식 : std::cin >> '변수';
- 다음의 구조로 연속적인 데이터의 입력을 요구할 수 있다. std::cin>>'변수1'>>'변수2';
- 배열 기반의 문자열 입출력 예시) char name[100]; std::cin>>name;
- std::cout << "내 이름은 " << name << "입니다. \n"; 에서 '\n'과 같은 특수문자는 C언어에서와 같은 의미를 지닌다.
  다만, std::endl로 개행의 역할을 대신할 뿐이다.

- c언어에서는 동일한 이름의 함수가 정의되는 것을 허용하지 않는다. (c언어에서는 함수의 이름만 이용해서 호출 대상을 찾는다.)
- c++언어에서는 함수호출 시 전달되는 인자를 통해서 호출하고자 하는 함수의 구분이 가능하기 때문에
  매개변수의 선언형태가 다르다면, 동일한 이름의 함수 정의를 허용할 수 있다. 이러한 형태의 함수정의를 가리켜
  '함수 오버로딩'이라 한다. (c++언어에서는 함수의 이름과 매개변수의 선언을 이용해서 호출 대상을 찾는다.)
- 함수의 오버로딩이 가능 하려면 매개변수의 선언이 달라야 한다. (즉, 매개변수의 자료형 또는 개수가 달라야 매개변수가 서로 다른 것으로 본다.)
  void MyFunc(int n) {...}과 int MyFunc(int n) {...}는 함수의 반환형이 다른 거지, 함수 명과 매개변수는 동일하기 때문에 이러한 함수들은 오버로딩이 될 수 없다.
- 매개변수의 디폴트 값을 줄 수 있는데, 이는 함수 호출 시 인자를 전달하지 않으면 설정한 디폴트 값이 전달된 것으로 간주한다는 뜻이다. 
  매개변수에 디폴트 값이 설정되어 있으면, 선언된 매개변수의 수보다 적은 수의 인자전달이 가능하다.
  그리고 전달된느 인자는 왼쪽에서부터 채워져 나가고, 부족분은 디폴트 값으로 채워진다.

