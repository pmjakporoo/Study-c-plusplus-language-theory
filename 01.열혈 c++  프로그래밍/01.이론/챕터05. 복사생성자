1. c++ 스타일의 초기화
  int num = 20;
  int &ref = num;
  과 같은 방식으로 변수와 참조자를 선언 및 초기화 가능하고,
  int num(20);
  int &ref(num);
  과 같은 방식도 가능하다. 즉, 위와 아래 방식이 동일하게 작동한다.

  class SoSimple {
    int num1;
    int num2;
  public:
    SoSimple(int n1, int n2): num1(n1), num2(n2) {}
    void ShowSimpleData() {
      cout << num1 << endl;
      cout << num2 << endl;
    }
  }

  int main(void) {
    SoSimple sim1(15, 20);
    SoSimple sim2 = sim1; // SoSimple sim2(sim1)과 같다.
    sim2.ShowSimpleData();
  }

   SoSimple sim2 = sim1는 sim2 객체를 새로 생성해서 객체 sim1과 sim2간의 멤버 대 맴버 복사가 일어난다.

  즉, 
  int num1=num2;
  int num1(num2);
  이 두문장이 동일한 의미로 해석되듯이,

  SoSimple sim2 = sim1;
  SoSimple sim2(sim1);도 동일한 의미로 해석이 된다.

2. SoSimple sim2(sim1)
  SoSimple형 객체를 생성한다.
  객체의 이름은 sim2이다.
  sim1을 인자로 받을 수 있는 생성자의 호출을 통해서 객체 생성을 완료한다.

  즉, 위의 객체 생성문에서 호출하고자 하는 생성자는 다음과 같이 SoSimple 객체를 인자로 받을 수 있는 생성자이다.
  SoSimple(const SoSimple &copy) { ... }
  이러한 생성자를 가리켜 복사 생성자라고 부른다.
  맴버 대 맴버의 복사에 사용되는 원본을 변경시키는 것은 복사의 개념을 무너뜨리는 행위가 되니, 
  키워드 const를 삽입해서 이러한 실수를 막아 놓는 것이 좋다.
 
  그리고 다음의 문장도 
  SoSimple sim2 = sim1;
  실은 다음의 형태로 묵시적 변환이 되어서(자동으로 변환이 되어서) 객체가 생성되는 것이다.
  SoSimple sim2(sim1);
  

3.자동으로 삽입이 되는 디폴트 복사 생성자
  복사생성자의 삽입 없이도 맴버 대 맴버의 복사가 진행된다.
  즉, 복사생성자를 정의하지 않으면, 맴버대 맴버의 복사를 진행하는 디폴트 복사 생성자가 자동으로 삽입된다.

  class SoSimple {
    int num1;
    int num2;
  public:
    SoSimple(int n1, int n2): num1(n1), num2(n2) {}
    void ShowSimpleData() {
      cout << num1 << endl;
      cout << num2 << endl;
    }
  }

  위의 클래스는 다음의 클래스 정의와 완전히 동일하다. 디폴트 복사 생성자가 자동으로 삽입되기 때문이다.

  
  class SoSimple {
    int num1;
    int num2;
  public:
    SoSimple(int n1, int n2): num1(n1), num2(n2) {}
    SoSimple(const SoSimple &copy): num1(copy.num1), num2(copy.num2) {

    }
    void ShowSimpleData() {
      cout << num1 << endl;
      cout << num2 << endl;
    }
  }

4. 변환에 의한 초기화를 막고 싶다면 explicit로 막을 수 있다.
  SoSimple sim2 = sim1; 은 자동으로 SoSimple sim2(sim1);으로 묵시적 변환이 일어나서 복사 생성자가 호출된다.
  하지만 이렇게 묵시적 변환을 막고 SoSimple sim2(sim1)이렇게 명시해야 복사생성자가 호출되게 하고 싶다면,
  아래와 같이 복사생성자 앞에 explicit 키워드를 붙여주면 된다. (복사 생성자의 묵시적 호출을 허용하지 않음)

  explicit SoSimple(const SoSimple &copy): num1(copy.num1), num2(copy.num2) {
  }
  이렇게 explicit를 적어주면 대입연산자(ex.SoSimple sim2 = sim1;)를 이용한 객체의 생성 및 초기화는 불가능하다.

  explicit 키워드는 복사생성자에만 붙일 수 있는 것이 아니다.
  생성자에도 붙일 수 있다.

  
  class SoSimple {
    int num;

  public:
    explicit SoSimple(int n): num1(n1){}
    void ShowSimpleData() {
      cout << num << endl;
    }
  }

  이렇게 생성자 앞에 explicit를 붙여놓으면 
  SoSimple sim1 = 3; 과 같은 형태로 객체를 생성할 수 없다.
  SoSimple sim1(3); 과 같은 형태로 객체를 생성해야 한다.

참고) 복사생성자의 매개변수는 반드시 참조형이여야한다.

5. 디폴트 복사 생성자(얕은 복사)의 문제점
  디폴트 복사 생성자는 멤버대 멤버의 복사를 진행하는데, 이러한 방식의 복사를 가리켜 얕은복사라 한다.
  이는 멤버변수가 힙의 메모리 공간을 참조하는 경우에 문제가 된다. 

  예시코드) ShallowCopyError.cpp
  
