1. 구조체의 등장배경?
  - 연관 있는 데이터를 하나로 묶으면, 프로그램의 구현 및 관리가 용이하다.
  - 이렇게 부류를 형성하는 데이터들은 함께 생성, 이동 및 소멸된다는 특성이 있다.  
    그래서, 구조체는 연관있는 데이터를 묶을 수 있는 문법적 장치로 데이터의 표현에 매우 큰 도움을 준다.
  - c++에서는 별도의 typedef 선언 없이도 구조체 변수를 선언할 수 있다. 
    c++에서는 기본 자료형 변수의 선언방식이나 구조체를 기반으로 정의된 자료형의 변수 선언 방식에 차이가 없다.

  예제코드) 01.RacingCar.cpp
  - 정의된 세 개의 함수는 구조체 Car와 함께 부류를 형성하여, Car와 관련된 데이터의 처리를 담당하는 함수이다.
    그러나, 전역함수의 형태를 띠기 때문에 이 함수들이 구조체 Car에 종속적임을 나타내지 못하고 있는 상황이다.
    따라서 엉뚱하게도 다른 영역에서 이 함수를 호출하는 실수를 범할 수도 있는 상황이다.

2. 구조체 안에 함수 삽입하기
  - c++에서는 구조체 안에 함수를 삽입하는 것을 허용한다. 
  - 구조체 안에 삽입된 함수는 매개변수를 통해서 연산의 대상정보를 전달받지 않아도 된다.
    구조체 내에 선언된 변수에 직접 접근이 가능해졌기 때문이다.

  예제코드) RacingCarFuncAdd.cpp

3. 구조체 안에 enum 상수의 선언 
  - RacingCarFuncAdd.cpp에 다음의 매크로 상수들이 존재한다.

    #define ID_LEN		20
    #define MAX_SPD		200
    #define FUEL_STEP	2
    #define ACC_STEP	10
    #define BRK_STEP	10
    - 이들 상수 역시 구조체 Car에게만 의미가 있는 상수들이다.
      즉, 다른 영역에서 사용하도록 정의된 상수가 아니니, 이들 상수도 구조체 내에 포함시키는 것이 좋을 수 있다.
      혹은 이름공간을 이용해서 상수가 사용되는 영역을 명시하는 것도 또 다른 방법이 될 수 있다.

      예시코드) RacingCarEnum.cpp

4. 함수는 외부로 뺄 수 있다. 
  - 함수가 포함되어 있는 c++의 구조체를 보는 순간, 다음의 정보들의 쉽게 눈에 들어와야 코드의 분석이 용이하다.
    - 선언되어 있는 변수 정보
    - 정의되어 있는 함수 정보
  - 보통 프로그램을 분석할 때, 흐름 및 골격 위주로 분석하는 경우가 많다.
    그리고 이러한 경우에는 함수의 기능만 파악을 하지, 함수의 세부구현까지 신경을 쓰지는 않는다.  
    따라서 구조체를 보는 순간, 정의되어 있는 함수의 종류와 기능이 한눈에 들어오게끔 코드를 작성하는 것이 좋다.
    따라서 구조체 내에 정의된 함수의 수가 많거나 길이가 길다면, 다음과 같이 구조체 밖으로 함수를 빼낼 필요가 있다.

    struct Car {
      ...
      void ShowCarState();
      void Accel();
      ...
    }

    void Car::ShowCarState() {
      ...
    }

    void Car::Accel() {
      ...
    }

    즉, 함수의 원형 선언을 구조체 안에 두고, 함수의 정의를 구조체 밖으로 빼내는 것이다.
    다만 빼낸다음에 해당 함수가 어디에 정의되어 있는지에 대한 정보만 추가해주면된다. 

    예제코드) RacingCarOuterFunc.cpp
    - 구조체 안에 함수가 정의되어 있으면(함수의 원형 선언 및 함수의 몸체를 적으면) 다음의 의미가 더불어 내포된다.
      - 함수를 인라인으로 처리해라!
      반면 구조체 안에 함수의 원형선언을 구조체 안에 두고, 함수의 정의를 구조체 밖으로 빼면 이러한 의미가 사라진다.
      만약 이러한 의미를 살리고 싶다면 
        inline void Car::ShowCarState() {
          ...
        }

        inline void Car::Accel() {
        	...
        }

        inline void Car::Break() {
        	...
        }
      와 같이 키워드 inline을 이용해서 인라인 처리를 명시적으로 지시해야 한다. 

5. 클래스와 구조체의 유일한 차이점
  - c++에서 구조체는 클래스의 일종으로 간주된다.
  - 구조체에서 struct를 class로 바꾸면 구조체가 아닌 클래스가 된다.
    클래스로 바꾸게 되면 
        Car run99 = {"run99", 100, 0};
    과 같은 방식으로 객체를 생성하지 못한다.
    그 이유는, 클래스 내에 선언된 함수가 아닌, 다른 영역에서 변수를 초기화하려 했기 때문이다.
    클래스는 접근제어 지시자를 명시하지 않으면 기본적으로 private 즉, 클래스 내(클래스 내에 선언된 함수)에서만 접근이 허용되기 때문이다.
    따라서,
        Car run99;
    와 같은 방식으로 객체를 선언해야 한다.

6. 접근제어 지시자(접근제어 레이블)
  - c++의 접근제어 지시자는 다음과 같이 총 세가지가 존재한다.
    public, protected, private
      public:      어디서든 접근 허용
      protected:   상속관계에 놓여있을 때, 유도 클래스에서의 접근 허용
      private:     클래스 내(클래스 내에 정의된 함수)에서만 접근 허용

  예제코드) RacingCarClassBase.cpp
  - 접근제어 지시자 A가 선언되면, 그 이후에 등장하는 변수나 함수는 A에 해당하는 범위 내에서 접근이 가능하다.
  - 그러나 새로운 접근제어 지시자 B가 선언되면, 그 이후로 등장하는 변수나 함수는 B에 해당하는 범위 내에서 접근이 가능하다.
  - 함수의 정의를 클래스 밖으로 빼도, 이는 클래스의 일부이기 때문에, 함수 내에서는 private으로 선언된 변수에 접근이 가능하다.
  - 키워드 struct를 이용해서 정의한 구조체(클래스)에 선언된 변수와 함수에 별도의 접근제어 지시자를 선언하지 않으면, 모든 변수와 함수는 public으로 선언된다.
  - 키워드 class를 이용해서 정의한 클래스에 선언된 변수와 함수에 별도의 접근제어 지시자를 선언하지 않으면, 모든 변수와 함수는 private로 선언된다.

  참고) 접근제어 지시자의 뒤에는 세미콜론이 아닌 콜론이 붙는데, 이는 접근제어 지시자가 특정 위치정보를 알리는 레이블(라벨)이기 때문이다.  

7. 용어정리: 객체, 멤버변수, 멤버함수
  - 객체: 우리 주변에 존재하는 물건이나 대상 전부를 의미함
    멤버변수: 클래스를 구성하는 변수
      ex) 
        char gamerID(CAR_CONST::ID_LEN);
        int fuelGauge;
        int curSpeed;
    멤버함수: 클래스를 구성하는 함수
      ex) 
        void InitMembers(char * ID, int fuel);
        void ShowCarState();
    -> 멤버는 구성원이라는 의미를 담고 있다. 그래서 클래스를 구성하는 변수와 함수에 각각
       멤버변수, 멤버함수라는 이름을 붙인 것이다.

8. c++에서의 파일분할
  - c++은 클래스 별로 헤더파일과 소스파일을 생성해서 
    클래스의 선언과 정의를 분리하는 경우가 많기 때문에 많은 수의 파일이 만들어진다.

  - 클래스 Car를 대상으로 파일을 나눌 때에는 보통 다음과 같이 파일을 구분한다.
    Car.h: 클래스의 선언을 담는다.
      이는 컴파일러가 Car클래스와 관련된 문장의 오류를 잡아내는데 필요한 최소한의 정보로써,
      클래스를 구성하는 외형적인 틀을 보여준다.
      즉, 해당 코드는 클래스 Car와 관련된 문장의 옳고 그름을 판단하는데 사용된다.
        ex) main 함수 내부에서 run99.fuelGauge = 100; (fuelGauge가 private임을 확인하고 에러를 발생시킴)

    Car.cpp: 클래스의 정의(멤버함수의 정의)를 담는다.
      다른 문장의 컴파일에 필요한 정보를 가지고 있지 않다. 
      따라서 함수의 정의는 컴파일 된 이후에 링커에 의해 하나의 실행파일로 묶이기만 하면 된다.
        ex)
          void Car::InitMember(char * ID, int fuel) { ... }
          void Car::Accel() { ... }

    -> Car 클래스와 관련된 문장의 컴파일 정보로 사용되는 클래스 선언은 헤더파일에 저장을 해서,
       필요한 위치에 쉽게 포함될 수 있도록 해야 하며, 클래스의 정의는 소스 파일에 저장을 해서
       컴파일이 되도록 하면 된다.

9. 인라인 함수는 헤더파일에 함께 넣어야 한다.
  - 인라인 함수의 특징 : 컴파일 과정에서 함수의 호출 문이 있는 곳에 함수의 몸체 부분이 삽입이 된다.
    따라서, 파일 단위로 컴파일할 때, 함수의 호출 문장을 바로바로 함수의 몸체로 대체해야 하기 때문에 
    인라인 함수는 헤더파일에 함께 넣은 뒤, 필요 파일에 include를 해줘야 한다. 

    예제파일 ) 07.CarInline.h, CarInline.cpp, RacingInlineMain.cpp

  - 컴파일러는 파일 단위로 컴파일을 한다. 즉, A.cpp와 B.cpp를 동시에 컴파일해서 하나의 실행파일을 만든다해도
    A.cpp의 컴파일 과정에서 B.cpp를 참조하지 않으며, B.cpp의 컴파일 과정에서 A.cpp를 참조하지 않는다.
    그래서 클래스 선언과 인라인 함수의 정의를 함꼐 묶는 것이다.

10. 객체지향 프로그래밍의 이해 
  - 객체지향 프로그래밍은 현실에 존재하는 사물과 대상, 
    그리고 그에 따른 행동을 있는 그대로 실체화 시키는 형태의 프로그래밍이다.

11. 객체를 이루는 것은 데이터와 기능이다.
  - 객체는 하나 이상의 상태 정보(데이터)와 하나 이상의 행동(기능)으로 구성이 되며,
    상태 정보는 변수를 통해서 표현이 되고, 행동은 함수를 통해서 표현이 된다.
  - 클래스의 멤버변수 선언문에서 초기화까지 하는 것을 허용하지 않기 때문에
    선언 및 초기화가 동시에 이뤄져야 하는 
    - const 상수 
    - 참조자
    멤버변수는 멤버 이니셜라이저를 이용하여 멤버를 초기화 해야 한다.

12. 클래스 기반의 두 가지 객체 생성방법
  - 객체를 생성하지 않고, 클래스 안에 존재하는 변수에 접근하고, 함수를 호출하는 것이 가능한가? (X)
    클래스는 실체(즉, 객체)가 아닌 틀이다. 따라서 접근도 호출도 불가능하다.

  - 정의한 클래스를 실체화시키기 위해 즉, 객체화 시키는 과정이 필요하다.
    c++에서 정의하고 있는 두 가지 객체 생성 방법
      - ClassName objName; // 일반적인 변수의 선언 방식
      - ClassName * ptrObj = new ClassName; // 동적 할당 방식(힙 할당방식)

    예제코드)FruitSaleSim1.cpp

13. 객체 간의 대화방법
  - 하나의 객체가 다른 하나의 객체에게 메시지를 전달하는 방법은 함수호출을 기반으로 한다.   
    그래서 객체지향에서는 이러한 형태의 함수호출을 가리켜 메시지 전달이라한다.



    
