1. 구조체의 등장배경?
  - 연관 있는 데이터를 하나로 묶으면, 프로그램의 구현 및 관리가 용이하다.
  - 이렇게 부류를 형성하는 데이터들은 함께 생성, 이동 및 소멸된다는 특성이 있다.  
    그래서, 구조체는 연관있는 데이터를 묶을 수 있는 문법적 장치로 데이터의 표현에 매우 큰 도움을 준다.
  - c++에서는 별도의 typedef 선언 없이도 구조체 변수를 선언할 수 있다. 
    c++에서는 기본 자료형 변수의 선언방식이나 구조체를 기반으로 정의된 자료형의 변수 선언 방식에 차이가 없다.

  예제코드) 01.RacingCar.cpp
  - 정의된 세 개의 함수는 구조체 Car와 함께 부류를 형성하여, Car와 관련된 데이터의 처리를 담당하는 함수이다.
    그러나, 전역함수의 형태를 띠기 때문에 이 함수들이 구조체 Car에 종속적임을 나타내지 못하고 있는 상황이다.
    따라서 엉뚱하게도 다른 영역에서 이 함수를 호출하는 실수를 범할 수도 있는 상황이다.

2. 구조체 안에 함수 삽입하기
  - c++에서는 구조체 안에 함수를 삽입하는 것을 허용한다. 
  - 구조체 안에 삽입된 함수는 매개변수를 통해서 연산의 대상정보를 전달받지 않아도 된다.
    구조체 내에 선언된 변수에 직접 접근이 가능해졌기 때문이다.

  예제코드) RacingCarFuncAdd.cpp

3. 구조체 안에 enum 상수의 선언 
  - RacingCarFuncAdd.cpp에 다음의 매크로 상수들이 존재한다.

    #define ID_LEN		20
    #define MAX_SPD		200
    #define FUEL_STEP	2
    #define ACC_STEP	10
    #define BRK_STEP	10
    - 이들 상수 역시 구조체 Car에게만 의미가 있는 상수들이다.
      즉, 다른 영역에서 사용하도록 정의된 상수가 아니니, 이들 상수도 구조체 내에 포함시키는 것이 좋을 수 있다.
      혹은 이름공간을 이용해서 상수가 사용되는 영역을 명시하는 것도 또 다른 방법이 될 수 있다.

      예시코드) RacingCarEnum.cpp

4. 함수는 외부로 뺄 수 있다. 
  - 함수가 포함되어 있는 c++의 구조체를 보는 순간, 다음의 정보들의 쉽게 눈에 들어와야 코드의 분석이 용이하다.
    - 선언되어 있는 변수 정보
    - 정의되어 있는 함수 정보
  - 보통 프로그램을 분석할 때, 흐름 및 골격 위주로 분석하는 경우가 많다.
    그리고 이러한 경우에는 함수의 기능만 파악을 하지, 함수의 세부구현까지 신경을 쓰지는 않는다.  
    따라서 구조체를 보는 순간, 정의되어 있는 함수의 종류와 기능이 한눈에 들어오게끔 코드를 작성하는 것이 좋다.
    따라서 구조체 내에 정의된 함수의 수가 많거나 길이가 길다면, 다음과 같이 구조체 밖으로 함수를 빼낼 필요가 있다.

    struct Car {
      ...
      void ShowCarState();
      void Accel();
      ...
    }

    void Car::ShowCarState() {
      ...
    }

    void Car::Accel() {
      ...
    }

    즉, 함수의 원형 선언을 구조체 안에 두고, 함수의 정의를 구조체 밖으로 빼내는 것이다.
    다만 빼낸다음에 해당 함수가 어디에 정의되어 있는지에 대한 정보만 추가해주면된다. 

    예제코드) RacingCarOuterFunc.cpp
    - 구조체 안에 함수가 정의되어 있으면(함수의 원형 선언 및 함수의 몸체를 적으면) 다음의 의미가 더불어 내포된다.
      - 함수를 인라인으로 처리해라!
      반면 구조체 안에 함수의 원형선언을 구조체 안에 두고, 함수의 정의를 구조체 밖으로 빼면 이러한 의미가 사라진다.
      만약 이러한 의미를 살리고 싶다면 
        inline void Car::ShowCarState() {
          ...
        }

        inline void Car::Accel() {
        	...
        }

        inline void Car::Break() {
        	...
        }
      와 같이 키워드 inline을 이용해서 인라인 처리를 명시적으로 지시해야 한다. 

5. 클래스와 구조체의 유일한 차이점
  - c++에서 구조체는 클래스의 일종으로 간주된다.
  - 구조체에서 struct를 class로 바꾸면 구조체가 아닌 클래스가 된다.
    클래스로 바꾸게 되면 
        Car run99 = {"run99", 100, 0};
    과 같은 방식으로 객체를 생성하지 못한다.
    그 이유는, 클래스 내에 선언된 함수가 아닌, 다른 영역에서 변수를 초기화하려 했기 때문이다.
    클래스는 접근제어 지시자를 명시하지 않으면 기본적으로 private 즉, 클래스 내(클래스 내에 선언된 함수)에서만 접근이 허용되기 때문이다.
    따라서,
        Car run99;
    와 같은 방식으로 객체를 선언해야 한다.

6. 접근제어 지시자(접근제어 레이블)
  - c++의 접근제어 지시자는 다음과 같이 총 세가지가 존재한다.
    public, protected, private
      public:      어디서든 접근 허용
      protected:   상속관계에 놓여있을 때, 유도 클래스에서의 접근 허용
      private:     클래스 내(클래스 내에 정의된 함수)에서만 접근 허용

  예제코드) RacingCarClassBase.cpp
  

    
