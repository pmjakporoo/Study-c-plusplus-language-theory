1. 클래스의 모든 객체가 멤버 함수를 공유한다.
 - 객체가 생성되면 멤버변수는 객체 내에 존재하지만, 멤버함수는 메모리의 한 공간에 별도로 위치하고선, 이 함수가 정의된 클래스의 모든 객체가 이를 공유하는 형태를 취한다.
 - 객체가 지니고 있는 멤버변수 대상의 연산이 진행되도록 함수를 호출하는 것이다. 
 이러한 사실을 알 수 있도록 두 개의 코드를 작성한다.
 첫번째는 c++로 단순한 클래스를 작성하는 것이고,
 두번쨰는 첫번째로 작성된 코드를 c언어 스타일의 구조체와 전역함수를 이용해서 작성한다.
 두번째 코드를 통해서 첫번쨰 코드가 작동되는 원리를 알 수 있다. 
 첫번째 코드) RealObjUnder1.cpp
 두번째 코드) RealObjUnder2.cpp

2. 가상함수의 동작원리와 가상함수 테이블
 - 이를 이해하면 c++이 c보다 느린 이유를 조금이나마 알 수 있다.
 
 - 가상함수의 원리를 이해하기 위한 예제코드) VirtualInternal.cpp
   - 한 개 이상의 가상함수를 포함하는 클래스에 대해서는 컴파일러가 가상함수 테이블(V-Table)이라는 것을 만든다. 
   - 예를들어 AAA객체의 Func1함수를 호출해야 하는 경우, 가상함수 테이블에서 해당 함수 정보를 참조하여 해당 함수를 호출한다.
   - 가상함수 테이블은 실제 호출되어야 할 함수의 위치정보를 담고 있는 테이블이며, key, value가 있다.
     - key : 호출하고자 하는 함수를 구분지어주는 구분자 역할
     - value : 구분자에 해당하는 함수의 주소정보를 알려주는 역할을 한다.

  [VirtualInternal.cpp에서 AAA클래스의 가상함수 테이블]
                    key         |   value
             void AAA::Func1()      a번지
             void BBB::Func2()      b번지

  [VirtualInternal.cpp에서 BBB클래스의 가상함수 테이블]
                    key         |   value
             void BBB::Func1()      c번지
             void AAA::Func2()      b번지
             void BBB::Func3()      d번지

 - AAA 클래스의 오버라이딩 된 가상함수 Func1에 대한 정보가 BBB 클래스의 가상함수 테이블에서는 보이지 않는다.
   이렇듯, 오버라이딩 된 가상함수의 주소정보는 유도 클래스의 가상함수 테이블에 포함되지 않는다.
   때문에 오버라이딩 된 가상함수를 호출하면 무조건 가장 마지막에 오버라이딩을 한 유도 클래스의 멤버함수가 호출되는 것이다.

3. 가상함수 테이블이 참조되는 방식
 - 가상함수 테이블은 main함수가 호출되기 이전에 메모리 공간에 할당된다. 참고로 가상함수 테이블은 객체의 생성과 상관없이
   메모리 공간에 할당된다. 이는 가상함수 테이블이 멤버함수의 호출에 사용되는 일종의 데이터이기 때문이다.
 - 가상함수를 하나 이상 멤버로 지니는 클래스의 객체에는 가상함수 테이블의 주소 값이 저장된다.(물론 이 주소 값은 우리가 
   직접 참조할 수 있는 주소값은 아니다. 다만 내무적으로 필요에 의해서 참조되는 주소 값일 뿐이다.)
 - 즉, BBB클래스의 가상함수 테이블을 살펴보면, 오버라이딩 된 AAA 클래스의 Func1함수에 대한 정보가 없음을 알 수 있다.
   그래서 BBB클래스의 Func1함수가 대신 호출되는데, 이것이 가상함수의 호출 원리이다.

4. 다중상속에 대한 견해
 - 다중상속이란 둘 이상의 클래스를 동시에 상속하는 것을 말한다. 
 - 다중상속은 득보다 실이 더 많은 문법이다. 그러니 사용하지 말아야 하며, 가능하다면 c++ 기본문법에서 제외시켜야 한다는 의견이 대부분이다.

5. 다중상속의 기본 방법
 예제코드) MultiInheri1.cpp

6. 다중상속의 모호성
 - 다중상속의 대상이 되는 두 기초 클래스에 동일한 이름의 멤버가 존재하는 경우에는 문제가 발생할 수 있다.
   이러한 경우에는 유도 클래스 내에서 멤버의 이름만으로 접근이 불가능하기 때문이다. 
   만약에 이름만으로 접근하려 든다면 컴파일러는 어느 클래스에 선언된 멤버에 접근해야되는지 헷갈리게 된다. 
   다중상속의 모호성과 해결 코드) MultiInheri2.cpp
