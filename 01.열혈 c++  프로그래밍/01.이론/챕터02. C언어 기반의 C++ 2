1. 참을 의미하는 true, 거짓을 의미하는 false
  - c++에서는 참과 거짓의 표현을 위한 키워드 true와 false를 정의하고 있다.
  - 그런데, true는 1이 아니며, false는 0이 아니다. 
    이것은 참과 거짓을 표현하기 위한 1바이트 크기의 데이터일 뿐이다.
    이 둘을 표현하거나 정수의 형태로 형 변환하는 경우에 각각 1과 0으로 변환되도록 정의되어 있을 뿐이다.
  - true와 false는 그 자체를 참과 거짓을 나타내는 목적으로 정의된 데이터로 인식하는 것이 바람직하다.
  - true와 false는 그 자체로 참과 거짓을 의미하는 데이터이기 때문에, 이들 데이터의 저장을 위한 자료형이 
    별도로 정의되어 있다. 이 둘을 가리켜 bool형 데이터라 한다. 이것은 기본자료형의 하나이다.
    ex) bool isTrueOne = true;
        bool isFalseOne = false;

2. 참조자의 이해 
  - 변수: 할당된 메모리 공간에 붙여진 이름이다. 그리고 그 이름을 통해서 해당 메모리 공간에 접근이 가능하다.
  - 할당된 하나의 메모리 공간에(변수에) 둘 이상의 이름을 부여할 수는 없는가?  -> 참조자를 이용하면 가능하다.
  - 이미 선언된 변수 앞에 &연산자가 오면 주소 값의 반환을 명령하는 뜻이 되지만,
    새로 선언되는 변수의 이름 앞에 등장하면, 이는 참조자의 선언을 뜻하게 된다.
  - 참조자는 자신이 참조하는 변수를 대신할 수 있는 또 하나의 이름이다. 
  - 참조자는 변수를 대상으로만 선언이 가능하다. (참조자 앞에 const를 붙이면 상수를 대상으로 선언이 가능하다.)
  - 참조자가 선언이 되고 나면, 변수와 차이가 없다. 
    함수 내에서 선언된 지역적 참조자는 지역변수와 마찬가지로 함수를 빠져나가면 소멸이 된다.

3. 참조자는 별칭이다.
  - 변수에 별칭(별명)을 하나 붙여주는 것이다.

4. 참조자의 수에는 제한이 없으며, 참조자를 대상으로도 참조자를 선언할 수 있다.
  ex)
    int num1= 2759;
    int &num2 = num1;
    int &num3 = num1;
    int &num4 = num1;
    int &num5 = num1;

  ex)
    int num1= 2759;
    int &num2 = num1;
    int &num3 = num2;
    int &num4 = num3;
    int &num5 = num4;

5. 참조자의 선언 가능 범위
  - 참조자는 변수에 대해서만 선언이 가능하고(참조자 앞에 const를 붙이면 상수를 대상으로 선언이 가능하다.),
    선언됨과 동시에 누군가를 참조해야만 한다.
    ex) int &ref = 20; (x)
        const int &ref = 20; (o)

  - 미리 참조자를 선언했다가 후에 누군가를 참조하는 것은 불가능하며, 
    참조의 대상을 바꾸는 것도 불가능하다.
    ex) int &ref; (x)

  - 참조자를 선언하면서 NULL로 초기화 하는 것도 불가능하다.
    ex) int &ref = NULL; (x)
  - 참조자는 '배열의 요소'(배열이 아닌 배열의 요소)에 대해서도 선언이 가능하다.
    배열의 요소(배열이 아니라, 배열의 요소는)는 변수로 간주되어 참조자의 선언이 가능하다.
  - 참조자는 포인터 변수에 대해서도 선언이 가능하다. (포인터 변수도 변수이기 때문)
  - 즉, const가 붙지 않은 참조자는 무조건 선언과 동시에 변수를 참조하도록 해야한다. 

6. Call-by-reference : 주소 값을 전달받아서, 함수 외부에 선언된 변수에 접근하는 형태의 함수 호출
  ex)
    int * SimpleFunc(int * ptr) {
      return ptr+1;
    }
    - 이 함수의 연산 주체는 값(value)이고, 함수 외부에 선언된 변수에 접근하지 않으므로
      call-by-reference 형태가 아닌 call-by-value 형태이다.
  - 즉, call-by-reference는 주소 값이 외부 변수의 참조 도구로 사용되는 함수의 호출을 뜻한다.
    이렇듯 주소 값이 전달되었다는 사실이 중요한 게 아니라, 주소 값이 참조의 도구로 사용되었다는 사실이 중요한 것이다.
    이러한 점이 call-by-value와 call-by-reference를 구분하는 기준이 된다.

  - c++에서는 함수 외부에 선언된 변수의 접근 방법으로 두 가지가 존재한다.
    - 주소 값을 이용한 call-by-reference 
    - 참조자를 이용한 call-by-reference 

7. 참조자를 이용한 call-by-reference 
  해당 예제 코드는 06.RefSwap.cpp이다.

8. 참조자를 이용한 Call-by-Reference의 황당함과 const 참조자 
  - 참조자 기반의 함수 정의에 좋은 점만 있는 것은 아니다.
    예를들어 코드를 분석하는 과정에 있다면, 함수의 호출 문장만 보고도 함수의 특성을 어느정도 판단할 수 있어야 한다.
    그런데, 참조자를 사용하는 경우, 함수의 원형을 확인해야 하고, 확인 결과 참조자가 매개변수의 선언에 와있다면, 
    함수의 몸체까지 문장 단위로 확인을 해서 참조자를 통한 값의 변경이 일어나는지를 확인해야 한다.
    -> 그러나 const 키워드를 사용하면, 이러한 단점을 어느정도 극복할 수 있다.

    ex) void HappyFunc(const int &ref) { ... }
    이러한 함수 원형만 보게 되면 적어도 참조자 ref를 이용한 값의 변경은 이뤄지지 않는다는 것을 알 수 있다. 

    -> 따라서, 함수 내에서, 참조자를 통한 값의 변경을 진행하지 않을 경우, 참조자를 const로 선언해서, 함수의 원형만 봐도
       값의 변경이 이뤄지지 않음을 알 수 있게 한다. 

9. 반환형이 참조형(Reference Type)인 경우
  예제 코드 -> 07.RefReturnOne.cpp
  - 참조형으로 반환된 값을 참조자에 저장하면, 참조의 관계가 하나 더 추가된다. 
  - 함수의 매개변수로 선언된 참조자는 지역 변수와 동일한 성격을 갖는다. 즉, 함수가 반환을 하면, 매개변수인 참조자는 소멸된다.  
    그러나, 그 것이 그 자체로 변수는 아니기 때문에 참조자가 참조하는 변수는 소멸되지 않는다.

  예제 코드 -> 08.RefReturnTwo.cpp
  - 반환형이 참조형인 경우, 반환 값을 무엇으로 저장하느냐에 따라서 그 결과에 차이가 있으므로, 
    적절한 선택을 해야만 한다.

  예제 코드 -> 09.RefReturnThree.cpp
  - 반환형이 참조형인 함수는 반환 값을 다음과 같이 두 가지 형태로 저장할 수 있다. 
    int num2 = RefRetFuncOne(num1); (O)
    int &num2 = RefRetFuncOne(num1); (O)

  - 반환형이 기본 자료형인 함수의 반환 값을 변수에 저장하거나 참조자에 const를 붙인 채로 참조해야한다. 
    반환 값은 상수나 다름 없기 때문이다. 
    int num2 = RefRetFuncTwo(num1); (O)
    int &num2 = RefRetFuncTwo(num1); (X)
    const int &num2 = RefRetFuncTwo(num1); (O)

10. 잘못된 참조의 반환
  int & RetuRefunc(int n) {
    int num = 20;
    num += n;
    return num; 
  }

  int &ref = RetuRefFunc(10); 
  -> RetuRefFunc함수가 반환될 때, 지역변수 num은 소멸된다.     
     따라서 지역변수를 참조형으로 반환하는 일은 없어야 한다. 

11. const 참조자의 또 다른 특징 
  - const int num = 20 과 같이 상수화된 변수에 대한 참조자 선언은 다음과 같이 const를 붙여줘야 한다.
    const int &ref = num;
    - 이렇게 선언이 되면 ref를 통한 값의 변경이 불가능하기 때문에 상수화에 대한 논리적인 문제점은 발생하지 않는다.
  
  - const 참조자는 다음과 같이 상수도 참조가 가능하다. 
    const int &ref = 50;
    참고) const 선언에 의해서 만들어진 변수를 상수화된 변수라고 한다.
          본래 상수가 아니라, 변수를 상수화시킨 것으로 정의하고 있기 때문이다.

12. 어떻게 참조자가 상수를 참조하는가?
  - 20, 30과 같은 숫자를 가리켜 리터럴 또는 리터럴 상수라고 한다. 그리고 이들은 다음의 특징을 지닌다.
    - 임시적으로 존재하는 값이다. 다음 행으로 넘어가면 존재하지 않는 상수다.
    - 이러한 상수는 메모리 공간에 저장은 되지만, 재 참조가 가능하지 않는다. 
      즉, 다음행으로 넘어가면 소멸되는 상수라고 해도 틀리지 않는다.
    - const 참조자를 이용해서 상수를 참조할 때, '임시변수'라는 것을 만든다. 그리고 이 장소에서 상수를 저장하고 선 참조자가 이를 참조하게끔 한다.
  -> 왜 상수의 참조가 가능하게 했을 까? 
    int Adder(const int &num1, const int &num2) {
        return num1+ num2;
    }

    Adder(3,4)
    와 같이 간단한 호출이 가능하도록 하기 위함이다.

    만약 이를 사용하지 않는다면 다음과 같이 리터럴 상수 3, 4를 변수에 대입후, 변수를 Adder함수를 호출 시 인자로 넣어줘야 한다.
      int n1 = 3;
      int n2 = 4;
  
      Adder(n1, n2);

  
  


