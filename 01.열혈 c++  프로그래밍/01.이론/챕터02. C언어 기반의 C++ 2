1. 참을 의미하는 true, 거짓을 의미하는 false
  - c++에서는 참과 거짓의 표현을 위한 키워드 true와 false를 정의하고 있다.
  - 그런데, true는 1이 아니며, false는 0이 아니다. 
    이것은 참과 거짓을 표현하기 위한 1바이트 크기의 데이터일 뿐이다.
    이 둘을 표현하거나 정수의 형태로 형 변환하는 경우에 각각 1과 0으로 변환되도록 정의되어 있을 뿐이다.
  - true와 false는 그 자체를 참과 거짓을 나타내는 목적으로 정의된 데이터로 인식하는 것이 바람직하다.
  - true와 false는 그 자체로 참과 거짓을 의미하는 데이터이기 때문에, 이들 데이터의 저장을 위한 자료형이 
    별도로 정의되어 있다. 이 둘을 가리켜 bool형 데이터라 한다. 이것은 기본자료형의 하나이다.
    ex) bool isTrueOne = true;
        bool isFalseOne = false;

2. 참조자의 이해 
  - 변수: 할당된 메모리 공간에 붙여진 이름이다. 그리고 그 이름을 통해서 해당 메모리 공간에 접근이 가능하다.
  - 할당된 하나의 메모리 공간에(변수에) 둘 이상의 이름을 부여할 수는 없는가?  -> 참조자를 이용하면 가능하다.
  - 이미 선언된 변수 앞에 &연산자가 오면 주소 값의 반환을 명령하는 뜻이 되지만,
    새로 선언되는 변수의 이름 앞에 등장하면, 이는 참조자의 선언을 뜻하게 된다.
  - 참조자는 자신이 참조하는 변수를 대신할 수 있는 또 하나의 이름이다. 
  - 참조자는 변수를 대상으로만 선언이 가능하다. (참조자 앞에 const를 붙이면 상수를 대상으로 선언이 가능하다.)
  - 참조자가 선언이 되고 나면, 변수와 차이가 없다. 
    함수 내에서 선언된 지역적 참조자는 지역변수와 마찬가지로 함수를 빠져나가면 소멸이 된다.

3. 참조자는 별칭이다.
  - 변수에 별칭(별명)을 하나 붙여주는 것이다.

4. 참조자의 수에는 제한이 없으며, 참조자를 대상으로도 참조자를 선언할 수 있다.
  ex)
    int num1= 2759;
    int &num2 = num1;
    int &num3 = num1;
    int &num4 = num1;
    int &num5 = num1;

  ex)
    int num1= 2759;
    int &num2 = num1;
    int &num3 = num2;
    int &num4 = num3;
    int &num5 = num4;

5. 참조자의 선언 가능 범위
  - 참조자는 변수에 대해서만 선언이 가능하고(참조자 앞에 const를 붙이면 상수를 대상으로 선언이 가능하다.),
    선언됨과 동시에 누군가를 참조해야만 한다.
    ex) int &ref = 20; (x)
        const int &ref = 20; (o)

  - 미리 참조자를 선언했다가 후에 누군가를 참조하는 것은 불가능하며, 
    참조의 대상을 바꾸는 것도 불가능하다.
    ex) int &ref; (x)

  - 참조자를 선언하면서 NULL로 초기화 하는 것도 불가능하다.
    ex) int &ref = NULL; (x)
  - 참조자는 '배열의 요소'(배열이 아닌 배열의 요소)에 대해서도 선언이 가능하다.
    배열의 요소(배열이 아니라, 배열의 요소는)는 변수로 간주되어 참조자의 선언이 가능하다.
  - 참조자는 포인터 변수에 대해서도 선언이 가능하다. (포인터 변수도 변수이기 때문)
  - 즉, const가 붙지 않은 참조자는 무조건 선언과 동시에 변수를 참조하도록 해야한다. 

6. Call-by-reference : 주소 값을 전달받아서, 함수 외부에 선언된 변수에 접근하는 형태의 함수 호출
  ex)
    int * SimpleFunc(int * ptr) {
      return ptr+1;
    }
    - 이 함수의 연산 주체는 값(value)이고, 함수 외부에 선언된 변수에 접근하지 않으므로
      call-by-reference 형태가 아닌 call-by-value 형태이다.
  - 즉, call-by-reference는 주소 값이 외부 변수의 참조 도구로 사용되는 함수의 호출을 뜻한다.
    이렇듯 주소 값이 전달되었다는 사실이 중요한 게 아니라, 주소 값이 참조의 도구로 사용되었다는 사실이 중요한 것이다.
    이러한 점이 call-by-value와 call-by-reference를 구분하는 기준이 된다.

  - c++에서는 함수 외부에 선언된 변수의 접근 방법으로 두 가지가 존재한다.
    - 주소 값을 이용한 call-by-reference 
    - 참조자를 이용한 call-by-reference 

7. 참조자를 이용한 call-by-reference 
  해당 예제 코드는 06.RefSwap.cpp이다.

8. 참조자를 이용한 Call-by-Reference의 황당함과 const 참조자 
  - 참조자 기반의 함수 정의에 좋은 점만 있는 것은 아니다.
    예를들어 코드를 분석하는 과정에 있다면, 함수의 호출 문장만 보고도 함수의 특성을 어느정도 판단할 수 있어야 한다.
    그런데, 참조자를 사용하는 경우, 함수의 원형을 확인해야 하고, 확인 결과 참조자가 매개변수의 선언에 와있다면, 
    함수의 몸체까지 문장 단위로 확인을 해서 참조자를 통한 값의 변경이 일어나는지를 확인해야 한다.
    -> 그러나 const 키워드를 사용하면, 이러한 단점을 어느정도 극복할 수 있다.

    ex) void HappyFunc(const int &ref) { ... }
    이러한 함수 원형만 보게 되면 적어도 참조자 ref를 이용한 값의 변경은 이뤄지지 않는다는 것을 알 수 있다. 

    -> 따라서, 함수 내에서, 참조자를 통한 값의 변경을 진행하지 않을 경우, 참조자를 const로 선언해서, 함수의 원형만 봐도
       값의 변경이 이뤄지지 않음을 알 수 있게 한다. 

9. 반환형이 참조형(Reference Type)인 경우
  예제 코드 -> 07.RefReturnOne.cpp
  - 참조형으로 반환된 값을 참조자에 저장하면, 참조의 관계가 하나 더 추가된다. 
  - 함수의 매개변수로 선언된 참조자는 지역 변수와 동일한 성격을 갖는다. 즉, 함수가 반환을 하면, 매개변수인 참조자는 소멸된다.  
    그러나, 그 것이 그 자체로 변수는 아니기 때문에 참조자가 참조하는 변수는 소멸되지 않는다.

  예제 코드 -> 08.RefReturnTwo.cpp

  예제 코드 -> 09.RefReturnThree.cpp

  


