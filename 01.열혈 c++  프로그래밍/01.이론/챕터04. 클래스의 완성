1. 정보은닉의 이해
  예시코드) 01. RectangleFault.cpp
  - 객체가 멤버변수로 등장할 수 있다.
  - 해당 코드는 프로그래머의 실수에 대한 대책이 하나도 준비되어 있지 않다.
    (ex. 외부에서 범위를 넘어선 값이 들어와도 어쩔 도리가 없다.)
  - 제한된 방법으로의 접근만 허용을 해서 잘못된 값이 저장되지 않도록 도와야 하고,
    또 실수를 했을 때, 실수가 쉽게 발견되도록 해야 한다.

  예시코드) 02.Point.h
  - 멤버변수를 private로 선언해서 임의로 값이 저장되는 것을 막았다.
    즉, 정보를 은닉한 상황이다.
    대신에 값의 저장 및 참조를 위한 함수를 추가로 정의하였다.
    따라서, 이 함수 내에서 멤버변수에 저장되는 값을 제한할 수 있게 되었다.

  예시코드) 02.Point.cpp
  - 멤버변수에 값을 저장하는 함수들은 0이상 100이하의 값이 전달되지 않으면, 
    에러 메시지를 출력하면서 값의 저장을 허용하지 않는 형태로 정의 되었다.
    따라서 잘못된 값이 저장되지 않을 뿐더러, 값이 잘못 전달되는 경우 출력메시지를 통해
    문제가 있음을 확인할 수 있다.

    -> 멤버변수를 private로 선언하고, 해당 변수에 접근하는 함수를 별도로 정의해서,
       안전한 형태로 멤버변수의 접근을 유도하는 것이 바로 정보은닉이며,
       이는 좋은 클래스가 되기 위한 기본 조건이 된다.

    - int GetX() const, bool SetX(int xpos)와 같은 함수를 가리켜 엑세스 함수라하는데,
      이들은 멤버변수를 private로 선언하면서 클래스 외부에서의 멤버변수 접근을 목적으로 정의되는 함수이다.

2. const 함수 
  ex)
    int GetX() const;
    int GetY() const;
    
    와 같은 함수는 다음 내용을 선언하는 것이다.
      - const 함수 내에서는 멤버변수에 저장된 값을 변경하지 않겠다.
      - const 함수 내에서는 const가 아닌 함수의 호출이 제한된다.
      -> const로 선언되지 않은 함수는 아무리 멤버변수에 저장된 값을 변경하지 않더라도,
         변경할 수 있는 능력을 지닌 함수이다. 따라서 이러한 변경이 가능한 함수의 호출을 
         아예 허용하지 않는 것이다.
        ex)
            class EasyClass {
              int num;
            public:
              void InitNum(int n) {
                num = n;
              }
              int GetNum() {
                return num;
              }
              void ShowNum() const {
                cout << GetNum() << endl; 
              }
            }

            class LiveClass {
              int num;
            public:
              void InitNum(const EasyClass &easy) {
                num = easy.GetNum();
              }
            }

          와 같은 코드에서 50행과 58행에서 컴파일 에러가 발생한다.
          50행 컴파일 에러 이유 : const함수 내부에서 const함수가 아닌 함수를 호출하고 있기 때문이다.
          58행 컴파일 에러 이유 : 57행 easy가 const 참조자인데, const 참조자를 이용해서는 const 함수만 호출이 가능하기 때문이다.
    - const 참조자를 이용해서는 const 함수만 호출이 가능하다!
3. 캡슐화
  - ex) 콘택 600: 코와 관련 있는 증상(콧물, 재채기, 코막힘)의 감기약과 관련된 class예제
        예제코드) Encaps1.cpp - 캡슐화가 무너진 사례가 되는 코드
        - 코감기는 항상 콧물, 재채기, 코막힘을 동반하므로 이 세가지 약을 동시에 먹을 수 있게 캡슐화 과정이 필요하다.

        예제코드) Encaps2.cpp - Encaps1.cpp 를 캡슐화한 코드

4. 생성자와 소멸자
  - 생성자 특징:
    - 클래스의 이름과 함수의 이름이 동일하다
    - 반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.
    - 객체 생성 시 딱 한번 호출된다.
    - 생성자도 함수의 일종이니 오버로딩이 가능하다
    - 생성자도 함수의 일종이니 매개변수에 디폴트 값을 설정할 수 있다.

  예제코드 ) 04.Constructor1.cpp
  - 여기에서 
    SimpleClass(int n1 = 0, int n2 = 0) { 
    	num1 = n1;
    	num2 = n2;
    }	
    이 부분의 주석을 풀어버리면 4개의 생성자 중에 어떠한 생성자를 호출해야 할 지 애매해진다. 
    왜냐하면 위의 생성자 코드는 나머지 생성자를 대체할 수 있는 생성자이기 때문이다.
  - SimpleClass() {
	    num1 = 0;
	    num2 = 0;
    } 이 생성자를 이용해서 객체를 생성하기 위해 다음과 같이 문장을 구성하면 안된다.
      SimpleClass sc1() (x)
      대신 다음과 같이 구성을 해야 한다.
      SimpleClass sc1;  (o)
      SimpleClass * ptr1 = new SimpleClass; (o)
      SimpleClass * ptr2 = new SimpleClass(); (o)

      왜 SimpleClass sc1() 이런 방식으로 생성자를 이용해서 객체를 생성할 수 없는 것인가?
        -> SimpleClass sc1() {
            SimpleClass sc(20, 30);
            return sc;
          }
          함수가 있다고 가정을 하면 
          SimpleClass sc1()이러한 표현은 함수의 원형을 선언한 것이다.
          즉, 이 문장을 void형(인자를 받지 않는) 생성자의 호출문으로 인정해버리면, 컴파일러는 이러한 문장을 
          만났을 때, 이것이 객체 생성문인지 함수의 원형 선언인지를 구분할 수 없게 된다. 
          그래서 이러한 유형의 문장은 객체 생성이 아닌, 함수의 원형 선언에만 사용하기로 약속하였다.

5. 멤버 이니셜라이저를 이용한 멤버 초기화
 - 멤버 이니셜라이저는 멤버 변수로 선언된 객체의 생성자 호출에 활용된다.
 - 멤버 이니셜라이저는 객체가 아닌 멤버의 초기화에도 사용할 수 있다.
   - const 변수, 참조자 즉, 선언과 동시에 초기화가 이뤄져야하는 것을 대상으로 멤버 이니셜라이저를 하면 
     이들도 멤버변수로 선언될 수 있다.
 - 멤버 이니셜라이저를 이용하면 선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성된다. 
 - 멤버 이니셜라이저를 사용하다 보면, 생성자의 몸체 부분이 그냥 비는 일이 종종 발생한다. 
	
       
