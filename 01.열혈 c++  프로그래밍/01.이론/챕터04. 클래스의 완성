1. 정보은닉의 이해
  예시코드) 01. RectangleFault.cpp
  - 객체가 멤버변수로 등장할 수 있다.
  - 해당 코드는 프로그래머의 실수에 대한 대책이 하나도 준비되어 있지 않다.
    (ex. 외부에서 범위를 넘어선 값이 들어와도 어쩔 도리가 없다.)
  - 제한된 방법으로의 접근만 허용을 해서 잘못된 값이 저장되지 않도록 도와야 하고,
    또 실수를 했을 때, 실수가 쉽게 발견되도록 해야 한다.

  예시코드) 02.Point.h
  - 멤버변수를 private로 선언해서 임의로 값이 저장되는 것을 막았다.
    즉, 정보를 은닉한 상황이다.
    대신에 값의 저장 및 참조를 위한 함수를 추가로 정의하였다.
    따라서, 이 함수 내에서 멤버변수에 저장되는 값을 제한할 수 있게 되었다.

  예시코드) 02.Point.cpp
  - 멤버변수에 값을 저장하는 함수들은 0이상 100이하의 값이 전달되지 않으면, 
    에러 메시지를 출력하면서 값의 저장을 허용하지 않는 형태로 정의 되었다.
    따라서 잘못된 값이 저장되지 않을 뿐더러, 값이 잘못 전달되는 경우 출력메시지를 통해
    문제가 있음을 확인할 수 있다.

    -> 멤버변수를 private로 선언하고, 해당 변수에 접근하는 함수를 별도로 정의해서,
       안전한 형태로 멤버변수의 접근을 유도하는 것이 바로 정보은닉이며,
       이는 좋은 클래스가 되기 위한 기본 조건이 된다.

    - int GetX() const, bool SetX(int xpos)와 같은 함수를 가리켜 엑세스 함수라하는데,
      이들은 멤버변수를 private로 선언하면서 클래스 외부에서의 멤버변수 접근을 목적으로 정의되는 함수이다.

2. const 함수 
  ex)
    int GetX() const;
    int GetY() const;
    
    와 같은 함수는 다음 내용을 선언하는 것이다.
      - const 함수 내에서는 멤버변수에 저장된 값을 변경하지 않겠다.
      - const 함수 내에서는 const가 아닌 함수의 호출이 제한된다.
      -> const로 선언되지 않은 함수는 아무리 멤버변수에 저장된 값을 변경하지 않더라도,
         변경할 수 있는 능력을 지닌 함수이다. 따라서 이러한 변경이 가능한 함수의 호출을 
         아예 허용하지 않는 것이다.
        ex)
            class EasyClass {
              int num;
            public:
              void InitNum(int n) {
                num = n;
              }
              int GetNum() {
                return num;
              }
              void ShowNum() const {
                cout << GetNum() << endl; 
              }
            }

            class LiveClass {
              int num;
            public:
              void InitNum(const EasyClass &easy) {
                num = easy.GetNum();
              }
            }

          와 같은 코드에서 50행과 58행에서 컴파일 에러가 발생한다.
          50행 컴파일 에러 이유 : const함수 내부에서 const함수가 아닌 함수를 호출하고 있기 때문이다.
          58행 컴파일 에러 이유 : 57행 easy가 const 참조자인데, const 참조자를 이용해서는 const 함수만 호출이 가능하기 때문이다.
    - const 참조자를 이용해서는 const 함수만 호출이 가능하다!
3. 캡슐화
  - ex) 콘택 600: 코와 관련 있는 증상(콧물, 재채기, 코막힘)의 감기약과 관련된 class예제
        예제코드) Encaps1.cpp - 캡슐화가 무너진 사례가 되는 코드
        - 코감기는 항상 콧물, 재채기, 코막힘을 동반하므로 이 세가지 약을 동시에 먹을 수 있게 캡슐화 과정이 필요하다.

        예제코드) Encaps2.cpp - Encaps1.cpp 를 캡슐화한 코드

4. 생성자와 소멸자
  - 생성자 특징:
    - 클래스의 이름과 함수의 이름이 동일하다
    - 반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.
    - 객체 생성 시 딱 한번 호출된다.
    - 생성자도 함수의 일종이니 오버로딩이 가능하다
    - 생성자도 함수의 일종이니 매개변수에 디폴트 값을 설정할 수 있다.

  예제코드 ) 04.Constructor1.cpp
  - 여기에서 
    SimpleClass(int n1 = 0, int n2 = 0) { 
    	num1 = n1;
    	num2 = n2;
    }	
    이 부분의 주석을 풀어버리면 4개의 생성자 중에 어떠한 생성자를 호출해야 할 지 애매해진다. 
    왜냐하면 위의 생성자 코드는 나머지 생성자를 대체할 수 있는 생성자이기 때문이다.
  - SimpleClass() {
	    num1 = 0;
	    num2 = 0;
    } 이 생성자를 이용해서 객체를 생성하기 위해 다음과 같이 문장을 구성하면 안된다.
      SimpleClass sc1() (x)
      대신 다음과 같이 구성을 해야 한다.
      SimpleClass sc1;  (o)
      SimpleClass * ptr1 = new SimpleClass; (o)
      SimpleClass * ptr2 = new SimpleClass(); (o)

      왜 SimpleClass sc1() 이런 방식으로 생성자를 이용해서 객체를 생성할 수 없는 것인가?
        -> SimpleClass sc1() {
            SimpleClass sc(20, 30);
            return sc;
          }
          함수가 있다고 가정을 하면 
          SimpleClass sc1()이러한 표현은 함수의 원형을 선언한 것이다.
          즉, 이 문장을 void형(인자를 받지 않는) 생성자의 호출문으로 인정해버리면, 컴파일러는 이러한 문장을 
          만났을 때, 이것이 객체 생성문인지 함수의 원형 선언인지를 구분할 수 없게 된다. 
          그래서 이러한 유형의 문장은 객체 생성이 아닌, 함수의 원형 선언에만 사용하기로 약속하였다.

5. 멤버 이니셜라이저를 이용한 멤버 초기화
 - 멤버 이니셜라이저는 멤버 변수로 선언된 객체의 생성자 호출에 활용된다.
 - 멤버 이니셜라이저는 객체가 아닌 멤버의 초기화에도 사용할 수 있다.
   - const 변수, 참조자 즉, 선언과 동시에 초기화가 이뤄져야하는 것을 대상으로 멤버 이니셜라이저를 하면 
     이들도 멤버변수로 선언될 수 있다.
 - 멤버 이니셜라이저를 이용하면 선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성된다. 
 - 멤버 이니셜라이저를 이용하면 초기화의 대상을 명확히 인식할 수 있다.
 - 성능에 약간의 이점이 있다.
 - 멤버 이니셜라이저를 사용하다 보면, 생성자의 몸체 부분이 그냥 비는 일이 종종 발생한다. 
 ex)
  class Rectangle{

    Point upLeft;
	...
    public:
	Rectangle(const int &x1, const int &y1): upLeft(x1, y1) {}
	...
  }
  과 같은 코드에서 다음의 내용이 멤버 이니셜라이저이다.
  : upLeft(x1, y1) 
  이것이 의미하는 바는 다음과 같다.
   "객체 upLeft의 생성과정에서 x1, y1을 인자로 전달받는 생성자를 호출하라."

 6. 객체의 생성과정
  - 메모리 공간의 할당 
  - 이니셜라이저를 이용한 멤버변수(객체)의 초기화
    (이니셜라이저가 선언되지 않았다면 메모리 공간의 할당과 생성자의 몸체부분의 실행으로 객체 생성은 완성된다.)
  - 생성자의 몸체부분 실행

 7. 디폴트 생성자
  - 메모리 공간의 할당 이후에 생성자의 호출까지 완료되어야 객체라 할 수 있다.
    즉, 객체가 되기 위해서는 반드시 하나의 생성자가 호출되어야 한다.
    생성자를 정의하지 않은 클래스에는 c++ 컴파일러에 의해서 디폴트 생성자라는 것이 자동으로 삽입된다.
    그런데 디폴트 생성자는 인자를 받지 않으며, 내부적으로 아무런 일도 하지 않는 생성자이다.
    따라서 모든 객체는 한번의 생성자 호출을 동반한다.
    이는 new 연사자를 이용한 객체의 생성에도 해당하는 이야기다.
    아래와 같이 객체를 생성해도 객체의 생성과정에서 생성자가 호출된다.
    AAA * ptr = new AAA;
    단, 다음과 같이 C언어의 malloc함수를 대신 이용하면 생성자는 호출되지 않는다.
    AAA * ptr = (AAA*)malloc(sizeof(AAA));
    -> 따라서, 객체를 동적으로 할당하는 경우에는 반드시 new연산자를 이용해야 한다.
 - 생성자가 하나도 정의되어 있지 않을 때 디폴트 생성자가 삽입이된다. 
   만약, 매개변수를 2개 받는 생성자를 직접 삽입했는데, 객체 생성 시 매개변수를 적지 않는다면 문제가 발생한다.

8. private 생성자
 - 객체의 생성방법을 제한하고자 하는 경우에 매우 유용하게 사용이 된다.

9. 소멸자
 - 객체 생성시 반드시 호출되는 것이 생성자라면, 객체 소멸 시 반드시 호출되는 것은 소멸자이다. 
 - 소멸자의 특징
   - 클래스의 이름 앞에 ~가 붙은 형태의 이름을 갖는다.
   - 반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.
   - 매개변수는 void형으로 선언되어야 하기 때문에 오버로딩도, 디폴트 값 설정도 불가능하다.
   - 소멸자는 객체 소멸 과정에서 자동으로 호출이 된다. 
   - 소멸자를 정의하지 않으면, 아무런 일도 하지 않는 디폴트 소멸자가 자동으로 삽입된다.
   - 소멸자는 대게 생성자에서 할당한 리소스의 소멸에 사용된다.

10.객체 배열
 - 객체 기반의 배열은 다음 형태로 선언한다. (SoSimple이 클래스 이름이다.)
    SoSimple arr[10];
   이러한 형태로 선언해도 생성자는 호출된다. 단, 배열의 선언 과정에서는 호출할 생성자를 
   별도로 명시하지 못한다.(생성자에 인자를 전달하지 못한다.)
   따라서, 다음 형태의 생성자가 반드시 정의되어 있어야 한다.
    SoSimple() { ... }
   배열 선언 이후에 각 요소를 원하는 값으로 초기화 시키길 원한다면, 일일이 초기화의 과정을 별도로 거쳐야 한다.

       
