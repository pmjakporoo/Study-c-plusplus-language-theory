1. 정보은닉의 이해
  예시코드) 01. RectangleFault.cpp
  - 객체가 멤버변수로 등장할 수 있다.
  - 해당 코드는 프로그래머의 실수에 대한 대책이 하나도 준비되어 있지 않다.
    (ex. 외부에서 범위를 넘어선 값이 들어와도 어쩔 도리가 없다.)
  - 제한된 방법으로의 접근만 허용을 해서 잘못된 값이 저장되지 않도록 도와야 하고,
    또 실수를 했을 때, 실수가 쉽게 발견되도록 해야 한다.

  예시코드) 02.Point.h
  - 멤버변수를 private로 선언해서 임의로 값이 저장되는 것을 막았다.
    즉, 정보를 은닉한 상황이다.
    대신에 값의 저장 및 참조를 위한 함수를 추가로 정의하였다.
    따라서, 이 함수 내에서 멤버변수에 저장되는 값을 제한할 수 있게 되었다.

  예시코드) 02.Point.cpp
  - 멤버변수에 값을 저장하는 함수들은 0이상 100이하의 값이 전달되지 않으면, 
    에러 메시지를 출력하면서 값의 저장을 허용하지 않는 형태로 정의 되었다.
    따라서 잘못된 값이 저장되지 않을 뿐더러, 값이 잘못 전달되는 경우 출력메시지를 통해
    문제가 있음을 확인할 수 있다.

    -> 멤버변수를 private로 선언하고, 해당 변수에 접근하는 함수를 별도로 정의해서,
       안전한 형태로 멤버변수의 접근을 유도하는 것이 바로 정보은닉이며,
       이는 좋은 클래스가 되기 위한 기본 조건이 된다.

    - int GetX() const, bool SetX(int xpos)와 같은 함수를 가리켜 엑세스 함수라하는데,
      이들은 멤버변수를 private로 선언하면서 클래스 외부에서의 멤버변수 접근을 목적으로 정의되는 함수이다.

2. const 함수 
  ex)
    int GetX() const;
    int GetY() const;
    
    와 같은 함수는 다음 내용을 선언하는 것이다.
      - const 함수 내에서는 멤버변수에 저장된 값을 변경하지 않겠다.
      - const 함수 내에서는 const가 아닌 함수의 호출이 제한된다.
      -> const로 선언되지 않은 함수는 아무리 멤버변수에 저장된 값을 변경하지 않더라도,
         변경할 수 있는 능력을 지닌 함수이다. 따라서 이러한 변경이 가능한 함수의 호출을 
         아예 허용하지 않는 것이다.
        ex)
            class EasyClass {
              int num;
            public:
              void InitNum(int n) {
                num = n;
              }
              int GetNum() {
                return num;
              }
              void ShowNum() const {
                cout << GetNum() << endl; 
              }
            }

            class LiveClass {
              int num;
            public:
              void InitNum(const EasyClass &easy) {
                num = easy.GetNum();
              }
            }

          와 같은 코드에서 50행과 58행에서 컴파일 에러가 발생한다.
          50행 컴파일 에러 이유 : const함수 내부에서 const함수가 아닌 함수를 호출하고 있기 때문이다.
          58행 컴파일 에러 이유 : 57행 easy가 const 참조자인데, const 참조자를 이용해서는 const 함수만 호출이 가능하기 때문이다.
    - const 참조자를 이용해서는 const 함수만 호출이 가능하다!
3. 캡슐화
  - ex) 콘택 600: 코와 관련 있는 증상(콧물, 재채기, 코막힘)의 감기약과 관련된 class예제
        예제코드) Encaps1.cpp - 캡슐화가 무너진 사례가 되는 코드
        - 코감기는 항상 콧물, 재채기, 코막힘을 동반하므로 이 세가지 약을 동시에 먹을 수 있게 캡슐화 과정이 필요하다.

        예제코드) Encaps2.cpp - Encaps1.cpp 를 캡슐화한 코드

4. 생성자와 소멸자
  - 생성자 특징:
    - 클래스의 이름과 함수의 이름이 동일하다
    - 반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.
    - 객체 생성 시 딱 한번 호출된다.
    - 생성자도 함수의 일종이니 오버로딩이 가능하다
    - 생성자도 함수의 일종이니 매개변수에 디폴트 값을 설정할 수 있다.

  - 객체생성과정에 자동으로 호출되는 생성자에게 전달할 인자의 정보를 다음과 같이 추가해야 한다.
    SimpleClass sc(20); // 생성자에 20을 전달
    SimpleClass * ptr = new SimpleClass(30); // 생성자에 30을 전달


       
